---
title: "'ruler' functional API"
author: "Evgeni Chasnovski"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette contains some thoughts about `ruler` functional API.

## General thoughts

`ruler` is yet another data validation R package. Its main goal is to provide
tools for tidy data validation report. It is designed to work tightly with
[dplyr](https://github.com/tidyverse/dplyr).

- The main data format is [tibble](https://github.com/tidyverse/tibble) because 
there will be many operations with list-columns and because of its
'tidyverseness'.

- The main function is `expose`: it exposes rule breakers in supplied data. Its
output is always the unmodified input data with possibly changed attribute
`ruler_report` (name is subject to change);

- Input values for exposure:
    - Data;
    - Set of __named__ rules. Rule is a __function__ which takes some input and
    returns either `TRUE`/`FALSE` or logical object of the same structure as
    input. Result indicates whether ceratin element satisfy the rule. Rules are
    applied to __columns__ of data;
    - Variables (column names) for which exposure is done;
    - `prep` function: preparatory function that modifies input data. Its output
    should contain column `.id` for row identification;
  
- Exposure mechanism:
    - Add to data column '.id' via `tibble::rowid_to_column(var = ".id")` for
    row identification;
    - Premodify data with `mod_data <- prep(.data)`;
    - Apply rules with `mutate_at` (and other) to desired columns in `mod_data`.
    In this way one can leverage `dplyr` functionality such as grouping;
    - Extract validation report;

- The key concept of tidy data validation report is to __enable its__
__reproducibility__. Its format (for now) is a list with three elements:
    - `preps` - __named__ list of preparatory functions;
    - `rules` - __named__ list of rules;
    - `breakers` - a tibble with the data completely describing rule breakers
    (elements which don't satisfy the rule). Its has the following structure:
        - `prep` - name of applied preparatory function;
        - `rule` - name of rule;
        - `var` - name of column in which breaker is detected;
        - `id` - value of `.id` column describing the row in which particular
        breaker is detected.

- With the described framework it is possible to detect breakers not only in
form of elements in the raw data:
    - With certain `prep` transform every column to list-colum of length 1 with
    the previous column. In this form cell of the data is a column so one can
    __expose columns__ that don't satisfy __rule for column__. Also add `.id`
    column with value 0 which is used to say that "variable `var` as a whole
    doesn't satisfy certain rule";
    - With certain `prep` create new column `.all` which stores some aggregated
    information about the row and apply rules to it. In this way one can
    __expose rows__ that don't satisfy __rule for rows__. Variable name '.all'
    is used to say that "row as a whole with certain `id` doesn't satisfy
    certain rule";
    - With certain `prep` transform the data into tibble with one row two
    columns: `.id` with entry 0, `.all` as a list-column which contains the
    input data. In this way one can __expose data__ if it doesn't satisfy
    __rule for data__. Entry 0 in `.id` and variable name `.all` is used to
    say that "data as a whole doesn't satisfy certain rule";
    - With certain `prep` transform the __grouped data__ into tibble with one
    row, column `.id` and one list-column per group. Every list-column contains
    row subset of original data corresponding to certain group (group identifier
    is stored as column name). Column `.id` should contain element 0. In this
    way one can __expose group__ if it doesn't satisfy __rule for group__.
    Entries 0 in '.id' and column names representing groups are used to say that
    "group as a whole doesn't satisfy certain rule".

- There should be some mechanism to choose whether to apply rule to column
(whole column serves as rule input) or to map rule through column elements
(every element of a column serves as rule input). It is needed to simplify
process of rule creation because of the possible transofrmations described in
the previous section.

## Desired use cases

### Use case #1:

```{r Use case #1, eval = FALSE}
mtcars %>%
  expose_data(row_num = ~ nrow(.) > 10, col_num = ~ ncol(.) > 15) %>%
  expose_cols(mean_val = ~ mean(.) > 3,
              .vars = vars(qsec:carb)) %>%
  expose(
    group_count = ~ nrow(.) <= 8,
    .prep = preps(prep_group_count = . %>%
                    group_by(cyl, gear) %>%
                    embed_groups())
  ) %>%
  expose_at(is_even = ~ . %% 2 == 0,
            .vars = vars(vs, am)) %>%
  expose_at(
    ~ . > 200, .vars = vars(.all),
    # add_id() is applied by default before .prep
    .prep = preps(prep_row_sum = . %>% mutate(.all = rowSums(.)))
  ) %>%
  assert_breakers(explicit = FALSE) %>%
  get_breakers()
```

`expose_data`, `expose_cols` (and not mentioned `expose_groups`) are wrappers
around expose with argument '.prep' equals to `embed_data`, `embed_cols`,
`embed_groups` respectfuly.

This should return tibble with the following structure:

- `prep` consisting from 'embed_data', 'embed_cols', 'prep_group_count' and
`self` and 'prep_row_sum' (names are subject to change);
- `rule` consisting from 'row_num', 'col_num', 'mean_val', 'group_count',
'is_even' and 'rule..6' (name for unnamed rule which is sixth unique rule
applied);
- `var` and `id` representing coordinates of rule breakers.

Some ( __!!!not all!!!__ ) rows from breakers for this use case (names of group
is subject to change):

```{r Use case #1 results, echo = FALSE}
tibble::tribble(
               ~prep,         ~rule,   ~var, ~id,
        "embed_data",     "col_num", ".all",   0,
        "embed_cols",    "mean_val",   "vs",   0,
        "embed_cols",    "mean_val",   "am",   0,
        "embed_cols",    "mean_val", "carb",   0,
  "prep_group_count", "group_count", "8__3",   0,
              "self",     "is_even",   "am",   1,
              "self",     "is_even",   "am",   2,
      "prep_row_sum",     "rule..6", ".all",  19
)
```

After getting this validation report user can do whatever he/she likes: print
its summary, use for data repairment and so on.
